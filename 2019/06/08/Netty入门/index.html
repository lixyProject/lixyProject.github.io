<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty入门 | 相信飞鱼</title><meta name="description" content="一、Netty概述官方的介绍：  Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.  Netty是 一个异步事件驱动的网络应用程序框架，用于"><meta name="keywords" content="netty"><meta name="author" content="lixy"><meta name="copyright" content="lixy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2019/06/08/Netty%E5%85%A5%E9%97%A8/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Netty入门"><meta property="og:url" content="http://yoursite.com/2019/06/08/Netty%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="相信飞鱼"><meta property="og:description" content="一、Netty概述官方的介绍：  Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.  Netty是 一个异步事件驱动的网络应用程序框架，用于"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-06-07T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-03T07:16:43.204Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="操作系统算法" href="http://yoursite.com/2019/09/10/%E4%B8%BB%E5%AE%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"><link rel="next" title="Git命令学习" href="http://yoursite.com/2019/03/05/Git%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Netty概述"><span class="toc-number">1.</span> <span class="toc-text">一、Netty概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、为什么使用Netty"><span class="toc-number">2.</span> <span class="toc-text">二、为什么使用Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-NIO的缺点"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 NIO的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Netty的优点"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Netty的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、架构图"><span class="toc-number">3.</span> <span class="toc-text">三、架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、永远的Hello-Word"><span class="toc-number">4.</span> <span class="toc-text">四、永远的Hello Word</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-引入Maven依赖"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 引入Maven依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-创建服务端启动类"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 创建服务端启动类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-创建服务端处理器"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 创建服务端处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-创建客户端启动类"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 创建客户端启动类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-创建客户端处理器"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 创建客户端处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-测试"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、Netty的特性与重要组件"><span class="toc-number">5.</span> <span class="toc-text">五、Netty的特性与重要组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-taskQueue任务队列"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 taskQueue任务队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-scheduleTaskQueue延时任务队列"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 scheduleTaskQueue延时任务队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Future异步机制"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 Future异步机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Bootstrap与ServerBootStrap"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 Bootstrap与ServerBootStrap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-group"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 group()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-channel"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 channel()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-option-与childOption"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 option()与childOption()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-设置流水线-重点"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4 设置流水线(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-bind"><span class="toc-number">5.4.5.</span> <span class="toc-text">5.4.5 bind()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-6-优雅地关闭EventLoopGroup"><span class="toc-number">5.4.6.</span> <span class="toc-text">5.4.6 优雅地关闭EventLoopGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Channel"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-获取channel的状态"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 获取channel的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-获取channel的配置参数"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 获取channel的配置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-channel支持的IO操作"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3 channel支持的IO操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Selector"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 Selector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-PiPeline与ChannelPipeline"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 PiPeline与ChannelPipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-ChannelHandlerContext"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 ChannelHandlerContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-EventLoopGroup"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 EventLoopGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-1-轮询机制的实现原理"><span class="toc-number">5.9.1.</span> <span class="toc-text">5.9.1 轮询机制的实现原理</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">相信飞鱼</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Netty入门</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-06-08 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2019-06-08</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-03 15:16:43"><i class="fas fa-history fa-fw"></i> 更新于 2020-08-03</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p>
<blockquote>
<p>Netty is <em>an asynchronous event-driven network application framework</em> for rapid development of maintainable high performance protocol servers &amp; clients.</p>
</blockquote>
<p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p>
<h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p>
<h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p>
<ul>
<li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li>
<li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li>
<li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li>
</ul>
<h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p>
<ul>
<li>API使用简单，学习成本低。</li>
<li>功能强大，内置了多种解码编码器，支持多种协议。</li>
<li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li>
<li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li>
<li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li>
</ul>
<h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/173194d4a8fd419c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p>
<blockquote>
<p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p>
</blockquote>
<blockquote>
<p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p>
</blockquote>
<blockquote>
<p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p>
</blockquote>
<p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p>
<h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.20.Final&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MyServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;创建两个线程组 boosGroup、workerGroup</span><br><span class="line">        EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;创建服务端的启动对象，设置参数</span><br><span class="line">            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">            &#x2F;&#x2F;设置两个线程组boosGroup和workerGroup</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                &#x2F;&#x2F;设置服务端通道实现类型    </span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                &#x2F;&#x2F;设置线程队列得到连接个数    </span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                &#x2F;&#x2F;设置保持活动连接状态    </span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                &#x2F;&#x2F;使用匿名内部类的形式初始化通道对象    </span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            &#x2F;&#x2F;给pipeline管道设置处理器</span><br><span class="line">                            socketChannel.pipeline().addLast(new MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);&#x2F;&#x2F;给workerGroup的EventLoop对应的管道设置处理器</span><br><span class="line">            System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;);</span><br><span class="line">            &#x2F;&#x2F;绑定端口号，启动服务端</span><br><span class="line">            ChannelFuture channelFuture &#x3D; bootstrap.bind(6666).sync();</span><br><span class="line">            &#x2F;&#x2F;对关闭通道进行监听</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><br><span class="line"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class MyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取客户端发送过来的消息</span><br><span class="line">        ByteBuf byteBuf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;发送消息给客户端</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;发生异常，关闭通道</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors &#x3D; new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;创建bootstrap对象，配置参数</span><br><span class="line">            Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line">            &#x2F;&#x2F;设置线程组</span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                &#x2F;&#x2F;设置客户端的通道实现类型    </span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                &#x2F;&#x2F;使用匿名内部类初始化通道</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                            &#x2F;&#x2F;添加客户端通道的处理器</span><br><span class="line">                            ch.pipeline().addLast(new MyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;);</span><br><span class="line">            &#x2F;&#x2F;连接服务端</span><br><span class="line">            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync();</span><br><span class="line">            &#x2F;&#x2F;对通道关闭进行监听</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭线程组</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;发送消息到服务端</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;接收服务端发送过来的消息</span><br><span class="line">        ByteBuf byteBuf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p>
<p>MyServer打印结果:</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/173194df71b69cc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>MyClient打印结果：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/173194e2409505c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取到线程池eventLoop，添加线程，执行</span><br><span class="line">        ctx.channel().eventLoop().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(&quot;长时间的业务处理&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/173194f4d1d340fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;长时间的业务处理&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,5, TimeUnit.SECONDS);&#x2F;&#x2F;5秒后执行</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/173194f21adfa111?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 6666);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p>
<p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加监听器</span><br><span class="line">channelFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">    &#x2F;&#x2F;使用匿名内部类，ChannelFutureListener接口</span><br><span class="line">    &#x2F;&#x2F;重写operationComplete方法</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否操作成功	</span><br><span class="line">        if (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(&quot;连接成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;连接失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731950cf2dbd785?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p>
<p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731951012e334fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q" target="_blank" rel="noopener">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p>
<ul>
<li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li>
<li>workerGroup用于处理每一个连接发生的读写事件。</li>
</ul>
<p>一般创建线程组直接使用以下new就完事了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;使用一个常量保存</span><br><span class="line">    private static final int DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F;NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span><br><span class="line">        DEFAULT_EVENT_LOOP_THREADS &#x3D; Math.max(1, SystemPropertyUtil.getInt(</span><br><span class="line">                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class="line"></span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果不传入，则使用常量的值，也就是cpu核数的两倍</span><br><span class="line">        super(nThreads &#x3D;&#x3D; 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置bossGroup线程数为1</span><br><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">&#x2F;&#x2F;设置workerGroup线程数为16</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(16);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731951ae3c43228?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用debug模式可以看到</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731951f80b07785?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>通道类型有以下：</p>
<p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p>
<p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p>
<blockquote>
<p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p>
</blockquote>
<p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p>
<p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p>
<blockquote>
<p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;server端代码，跟上面几乎一样，只需改三个地方</span><br><span class="line">&#x2F;&#x2F;这个地方使用的是OioEventLoopGroup</span><br><span class="line">EventLoopGroup bossGroup &#x3D; new OioEventLoopGroup();</span><br><span class="line">ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">bootstrap.group(bossGroup)&#x2F;&#x2F;只需要设置一个线程组boosGroup</span><br><span class="line">        .channel(OioServerSocketChannel.class)&#x2F;&#x2F;设置服务端通道实现类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;client端代码，只需改两个地方</span><br><span class="line">&#x2F;&#x2F;使用的是OioEventLoopGroup</span><br><span class="line">EventLoopGroup eventExecutors &#x3D; new OioEventLoopGroup();</span><br><span class="line">&#x2F;&#x2F;通道类型设置为OioSocketChannel</span><br><span class="line">bootstrap.group(eventExecutors)&#x2F;&#x2F;设置线程组</span><br><span class="line">        .channel(OioSocketChannel.class)&#x2F;&#x2F;设置客户端的通道实现类型</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p>
<p>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p>
<blockquote>
<p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p>
</blockquote>
<h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p>
<p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p>
<p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p>
<p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p>
<p>SocketChannel参数，也就是childOption()常用的参数：</p>
<blockquote>
<p><strong>SO_RCVBUF</strong>     Socket参数，TCP数据接收缓冲区大小。 <strong>TCP_NODELAY</strong>     TCP参数，立即发送数据，默认值为Ture。 <strong>SO_KEEPALIVE</strong>     Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p>
</blockquote>
<p>ServerSocketChannel参数，也就是option()常用参数：</p>
<blockquote>
<p><strong>SO_BACKLOG</strong>     Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p>
</blockquote>
<p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p>
<h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p>
<p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用匿名内部类的形式初始化通道对象</span><br><span class="line">bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F;给pipeline管道设置自定义的处理器</span><br><span class="line">		socketChannel.pipeline().addLast(new MyServerHandler());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>处理器Handler主要分为两种：</p>
<blockquote>
<p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p>
</blockquote>
<p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p>
<p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p>
<p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p>
<ol>
<li>注册事件 fireChannelRegistered。</li>
<li>连接建立事件 fireChannelActive。</li>
<li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li>
<li>异常通知事件 fireExceptionCaught。</li>
<li>用户自定义事件 fireUserEventTriggered。</li>
<li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li>
<li>连接关闭事件 fireChannelInactive。</li>
</ol>
<p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p>
<ol>
<li>端口绑定 bind。</li>
<li>连接服务端 connect。</li>
<li>写事件 write。</li>
<li>刷新时间 flush。</li>
<li>读事件 read。</li>
<li>主动断开连接 disconnect。</li>
<li>关闭 channel 事件 close。</li>
</ol>
<blockquote>
<p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p>
</blockquote>
<h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p>
<p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p>
<h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;释放掉所有的资源，包括创建的线程</span><br><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p>
<h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p>
<blockquote>
<p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p>
</blockquote>
<p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p>
<p>如果上面这段说明比较抽象，下面还有一段说明：</p>
<blockquote>
<p>A channel provides a user:</p>
<p>the current state of the channel (e.g. is it open? is it connected?), the configuration parameters of the channel (e.g. receive buffer size), the I/O operations that the channel supports (e.g. read, write, connect, and bind), and the ChannelPipeline which handles all I/O events and requests associated with the channel.</p>
</blockquote>
<p>翻译大意：</p>
<p>channel为用户提供：</p>
<ol>
<li>通道当前的状态（例如它是打开？还是已连接？）</li>
<li>channel的配置参数（例如接收缓冲区的大小）</li>
<li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li>
</ol>
<h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpen(); &#x2F;&#x2F;如果通道打开，则返回true</span><br><span class="line">boolean isRegistered();&#x2F;&#x2F;如果通道注册到EventLoop，则返回true</span><br><span class="line">boolean isActive();&#x2F;&#x2F;如果通道处于活动状态并且已连接，则返回true</span><br><span class="line">boolean isWritable();&#x2F;&#x2F;当且仅当I&#x2F;O线程将立即执行请求的写入操作时，返回true。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上就是获取channel的四种状态的方法。</p>
<h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ChannelConfig config &#x3D; channel.config();&#x2F;&#x2F;获取配置参数</span><br><span class="line">&#x2F;&#x2F;获取ChannelOption.SO_BACKLOG参数,</span><br><span class="line">Integer soBackLogConfig &#x3D; config.getOption(ChannelOption.SO_BACKLOG);</span><br><span class="line">&#x2F;&#x2F;因为我启动器配置的是128，所以我这里获取的soBackLogConfig&#x3D;128</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>获取多条配置信息，使用getOptions()，代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChannelConfig config &#x3D; channel.config();</span><br><span class="line">Map&lt;ChannelOption&lt;?&gt;, Object&gt; options &#x3D; config.getOptions();</span><br><span class="line">for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">SO_REUSEADDR : false</span><br><span class="line">WRITE_BUFFER_LOW_WATER_MARK : 32768</span><br><span class="line">WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)</span><br><span class="line">SO_BACKLOG : 128</span><br><span class="line">以下省略...</span><br><span class="line">*&#x2F;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">	ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>客户端控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;收到服务端&#x2F;127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>连接</strong>操作，代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture connect &#x3D; channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));&#x2F;&#x2F;一般使用启动器，这种方式不常用</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取ChannelPipeline对象</span><br><span class="line">ChannelPipeline pipeline &#x3D; ctx.channel().pipeline();</span><br><span class="line">&#x2F;&#x2F;往pipeline中添加ChannelHandler处理器，装配流水线</span><br><span class="line">pipeline.addLast(new MyServerHandler());</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>中，我已经讲过Selector了。</p>
<p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731957c1e90bf2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p>
<p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731954229ab93ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p>
<h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p>
<p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731954657f33870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p>
<p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ChannelPipeline实现类DefaultChannelPipeline的构造器方法</span><br><span class="line">protected DefaultChannelPipeline(Channel channel) &#123;</span><br><span class="line">	this.channel &#x3D; ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</span><br><span class="line">	succeededFuture &#x3D; new SucceededChannelFuture(channel, null);</span><br><span class="line">	voidPromise &#x3D;  new VoidChannelPromise(channel, true);</span><br><span class="line">	&#x2F;&#x2F;设置头结点head，尾结点tail</span><br><span class="line">	tail &#x3D; new TailContext(this);</span><br><span class="line">	head &#x3D; new HeadContext(this);</span><br><span class="line">	</span><br><span class="line">	head.next &#x3D; tail;</span><br><span class="line">	tail.prev &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面我用一张图来表示，会更加清晰一点：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731954b31d6c9cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h2><p>我们先看一下EventLoopGroup的类图：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/1731955081291714?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p>
<p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p>
<p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p>
<h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger idx &#x3D; new AtomicInteger();</span><br><span class="line">private final EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public EventExecutor next() &#123;</span><br><span class="line">    &#x2F;&#x2F;idx.getAndIncrement()相当于idx++，然后对任务长度取模</span><br><span class="line">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/4/17319554d4546047?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public EventExecutor next() &#123;</span><br><span class="line">    return executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lixy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/06/08/Netty%E5%85%A5%E9%97%A8/">http://yoursite.com/2019/06/08/Netty%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">相信飞鱼</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/netty/">netty</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/09/10/%E4%B8%BB%E5%AE%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统算法</div></div></a></div><div class="next-post pull-right"><a href="/2019/03/05/Git%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git命令学习</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By lixy</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>